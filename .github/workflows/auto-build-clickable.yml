This is an interesting and complex request! To achieve this, we'll need to combine several GitHub Actions features:

    Scheduled Workflow: To periodically check for new GitLab tags.
    External API Call: To fetch the latest release tag from the GitLab project.
    Local State (GitHub Release Tag): To keep track of the last version we've processed on GitHub.
    Version Comparison: To determine if the GitLab tag is newer than our current GitHub release tag.
    Conditional Execution: To only run the clickable build and release creation if a new version is detected.
    GitHub Release Creation: To create the "alpha" release with the new tag.

Let's break down the approach and then provide the full workflow.
Approach

    GitLab API for Latest Release Tag:
        The GitLab Releases API provides a way to get the latest release. The URL format is generally: https://gitlab.com/api/v4/projects/{project_id}/releases/permalink/latest.
        For librewolf-community/browser/appimage, we need to find its project ID. You can find this by navigating to the project on GitLab and looking at the URL or using the GitLab API to search for projects. A quick check of the URL https://gitlab.com/librewolf-community/browser/appimage/-/releases shows it's project ID 38692737.
        We'll use curl and jq (a lightweight and flexible command-line JSON processor) to parse the JSON response and extract the tag_name.

    Storing the Latest GitHub Release Tag:
        We'll fetch the latest release tag from our own GitHub repository. GitHub has an API for this: https://api.github.com/repos/{owner}/{repo}/releases/latest.
        We'll also use curl and jq to extract this.

    Version Comparison:
        We need a way to compare semantic versions (e.g., v1.2.3 vs v1.2.4). A simple string comparison might not work correctly for all cases (e.g., v1.10.0 vs v1.9.0). We'll use a bash function with sort -V for robust semantic version comparison.

    Triggering the Workflow:
        We'll use a schedule trigger to run this workflow periodically (e.g., once an hour or once a day).
        We'll also keep workflow_dispatch for manual triggering.

    Creating the Alpha Release:
        We'll continue to use softprops/action-gh-release@v2.
        The name of the release will be "Alpha" and the tag_name will be the new GitLab version.

Workflow Implementation
YAML

name: Monitor GitLab Tag and Create Alpha Release

on:
  schedule:
    - cron: '0 * * * *' # Run every hour. Adjust as needed (e.g., '0 0 * * *' for daily)
  workflow_dispatch: # Allows manual trigger

jobs:
  check-and-release:
    runs-on: ubuntu-latest
    container: clickable/ci-20.04-amd64 # Use the specified Docker image

    # Permissions for GitHub API access (to read our own releases and create new ones)
    permissions:
      contents: write # Required for softprops/action-gh-release to create releases and tags
      pull-requests: write # Recommended for some release actions, though not strictly needed here for basic release

    steps:
      - name: Install jq
        run: |
          apt-get update
          apt-get install -y jq curl

      - name: Get latest GitLab release tag
        id: get_gitlab_tag
        run: |
          # Project ID for librewolf-community/browser/appimage
          GITLAB_PROJECT_ID="38692737"
          GITLAB_API_URL="https://gitlab.com/api/v4/projects/${GITLAB_PROJECT_ID}/releases/permalink/latest"

          echo "Fetching latest GitLab release from: $GITLAB_API_URL"
          GITLAB_RESPONSE=$(curl -s "$GITLAB_API_URL")

          # Check if the response is empty or indicates an error
          if [ -z "$GITLAB_RESPONSE" ]; then
            echo "Error: Empty response from GitLab API. Exiting."
            exit 1
          fi

          GITLAB_TAG=$(echo "$GITLAB_RESPONSE" | jq -r '.tag_name')

          if [ "$GITLAB_TAG" == "null" ] || [ -z "$GITLAB_TAG" ]; then
            echo "Error: Could not extract tag_name from GitLab API response."
            echo "Response: $GITLAB_RESPONSE"
            exit 1
          fi

          echo "Latest GitLab Tag: $GITLAB_TAG"
          echo "gitlab_tag=$GITLAB_TAG" >> $GITHUB_OUTPUT

      - name: Get latest GitHub release tag from this repo
        id: get_github_tag
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Automatically provided by GitHub Actions
        run: |
          GITHUB_API_URL="https://api.github.com/repos/${{ github.repository }}/releases/latest"

          echo "Fetching latest GitHub release from: $GITHUB_API_URL"
          GITHUB_RESPONSE=$(curl -s -H "Authorization: token $GITHUB_TOKEN" "$GITHUB_API_URL")

          # Check if the response is empty or indicates no releases exist yet
          if echo "$GITHUB_RESPONSE" | jq -e 'has("message") and .message == "Not Found"' >/dev/null; then
            echo "No existing GitHub releases found in this repository."
            LATEST_GITHUB_TAG="v0.0.0" # Set a baseline for comparison
          else
            LATEST_GITHUB_TAG=$(echo "$GITHUB_RESPONSE" | jq -r '.tag_name')
            if [ "$LATEST_GITHUB_TAG" == "null" ] || [ -z "$LATEST_GITHUB_TAG" ]; then
              echo "Error: Could not extract tag_name from GitHub API response. Assuming v0.0.0"
              echo "Response: $GITHUB_RESPONSE"
              LATEST_GITHUB_TAG="v0.0.0" # Fallback
            fi
          fi

          echo "Latest GitHub Tag: $LATEST_GITHUB_TAG"
          echo "github_tag=$LATEST_GITHUB_TAG" >> $GITHUB_OUTPUT

      - name: Compare versions and set output
        id: compare_versions
        run: |
          GITLAB_TAG="${{ steps.get_gitlab_tag.outputs.gitlab_tag }}"
          GITHUB_TAG="${{ steps.get_github_tag.outputs.github_tag }}"

          echo "Comparing GitLab Tag ($GITLAB_TAG) with GitHub Tag ($GITHUB_TAG)"

          # Use sort -V for semantic version comparison
          # If GITLAB_TAG is greater than GITHUB_TAG, then the echo will print GITLAB_TAG first
          # If they are equal, it will print GITLAB_TAG first, but they are the same
          # If GITHUB_TAG is greater, then echo will print GITHUB_TAG first
          HIGHEST_TAG=$(printf "%s\n%s" "$GITLAB_TAG" "$GITHUB_TAG" | sort -V | tail -n 1)

          if [ "$GITLAB_TAG" = "$HIGHEST_TAG" ] && [ "$GITLAB_TAG" != "$GITHUB_TAG" ]; then
            echo "Newer GitLab tag detected: $GITLAB_TAG"
            echo "run_clickable=true" >> $GITHUB_OUTPUT
            echo "new_release_tag=$GITLAB_TAG" >> $GITHUB_OUTPUT
          else
            echo "No newer GitLab tag found. Current: $GITLAB_TAG, Latest in GitHub: $GITHUB_TAG"
            echo "run_clickable=false" >> $GITHUB_OUTPUT
          fi

      - name: Build Click package for arm64
        if: steps.compare_versions.outputs.run_clickable == 'true'
        run: clickable build --arch arm64 --skip-review

      - name: Upload Click package artifacts (for workflow run)
        if: steps.compare_versions.outputs.run_clickable == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: click-packages-arm64-${{ steps.compare_versions.outputs.new_release_tag }}
          path: build/*/app/*.click
          retention-days: 7

      - name: Create Alpha Release
        if: steps.compare_versions.outputs.run_clickable == 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.compare_versions.outputs.new_release_tag }} # Use the new GitLab tag
          name: Alpha ${{ steps.compare_versions.outputs.new_release_tag }} # Set release name to "Alpha <version>"
          body: |
            Automated Alpha release for version ${{ steps.compare_versions.outputs.new_release_tag }}
            This release is based on the upstream GitLab tag: ${{ steps.compare_versions.outputs.new_release_tag }}
          prerelease: true # Mark as a pre-release (alpha)
          draft: false
          files: build/*/app/*.click # Attach the built files
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Required for this action
