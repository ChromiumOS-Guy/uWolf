// osk_controller_webcontent.js
// This script runs inside web content (pages) to detect focus changes in input fields.
// ==UserScript==
// @name         OSK Web Content Controller
// @namespace    http://ubuntutouch.com/osk/content
// @version      2.3 // Fixed setTimeout scope issue
// @description  Monitors input focus in web content and communicates with OSK Manager.
// @match        *://*/*
// @run-at       document-idle
// ==/UserScript==

(function(contentWindow) {
  // Ensure the script's main logic runs only once per content window.
  // Using a property on the contentWindow object itself.
  if (contentWindow.oskControllerContentLoaded) {
    return;
  }
  contentWindow.oskControllerContentLoaded = true; // Mark as loaded

  const SCRIPT_ID = "osk_controller_webcontent";
  const DEBUG_MODE = true; // Added DEBUG_MODE here for content script's own logging

  function log(...args) {
    // Content script's log function now uses sendAsyncMessage to pass logs to chrome.
    // The chrome injector's log function will then output this to console.
    // This allows centralized logging.
    if (DEBUG_MODE) {
      try {
        if (typeof sendAsyncMessage === 'function') { // Check if sendAsyncMessage is directly available
          sendAsyncMessage(`${SCRIPT_ID}:Log`, { args: ["[CONTENT LOG]", ...args] });
        } else {
          // Fallback to console.log if sendAsyncMessage isn't available (e.g., if script runs in a different context)
          console.log(`[${SCRIPT_ID} Fallback Log (no sendAsyncMessage)]`, ...args);
        }
      } catch (e) {
        console.error(`[${SCRIPT_ID} Logging Error]`, e, ...args);
      }
    }
  }

  log("osk_controller_webcontent.js is running.");

  let currentFocusedElement = null; // Track the currently focused text input

  /**
   * Identifies if an element is a text input field or contenteditable.
   * Adapted from OSK Browser UI Controller for web content.
   * @param {HTMLElement} element - The element to check.
   * @returns {boolean} - True if the element is an input, textarea, or contenteditable.
   */
  function isTextInputElement(element) {
    if (!element || typeof element.matches !== 'function') {
        return false;
    }
    // Check for standard text inputs, textareas, and elements with contenteditable attribute.
    // Excludes buttons, checkboxes, radios, and file inputs, and elements that are explicitly non-focusable.
    return element.matches(
      'input:not([type="button"]):not([type="submit"]):not([type="reset"]):not([type="checkbox"]):not([type="radio"]):not([type="file"]):not([type="image"]), textarea, [contenteditable="true"]'
    );
  }

  /**
   * Sends a message to the chrome process indicating focus status.
   * @param {string} eventType - 'OSK:Web_FocusIn' or 'OSK:Web_FocusOut'
   */
  function sendFocusMessage(eventType) {
    let currentUrl = 'N/A'; // Default value if location is not available
    try {
      // Safely check for contentWindow.location before accessing .href
      if (contentWindow && contentWindow.location && contentWindow.location.href) {
        currentUrl = contentWindow.location.href;
      } else {
        log("Warning: contentWindow.location not fully available. Using 'N/A' for URL.");
      }
    } catch (e) {
      log("Error accessing contentWindow.location for URL:", e);
      currentUrl = 'AccessError'; // Indicate an error occurred during access
    }

    try {
      sendAsyncMessage(eventType, {
        url: currentUrl, // Use the safely determined URL
        eventType: eventType
      });
      log(`Sent message: ${eventType} for ${currentUrl}`);
    } catch (e) {
      // This catch block will now correctly log if sendAsyncMessage itself fails
      log("ERROR: Could not send message to chrome via sendAsyncMessage (after URL check):", e);
    }
  }

  /**
   * Handles focusin events.
   * @param {Event} event
   */
  function handleFocusIn(event) {
    const target = event.target;
    if (isTextInputElement(target)) {
      if (currentFocusedElement !== target) { // Only send message if focus moved to a *new* input
        log("Web Focus IN on:", target.tagName, "Type:", target.type, "ID:", target.id, "Class:", target.className);
        currentFocusedElement = target;
        sendFocusMessage('OSK:Web_FocusIn');
      } else {
        log("Web Focus IN on already focused element. No message sent.");
      }
    }
  }

  /**
   * Handles focusout events.
   * Adapted from OSK Browser UI Controller for robust blur detection.
   * @param {Event} event
   */
  function handleFocusOut(event) {
    const target = event.target; // The element that lost focus

    // Only proceed if the element that lost focus was actually a text input
    if (!isTextInputElement(target)) {
        return;
    }

    // A small timeout is added to allow `document.activeElement` to update
    // This is crucial for distinguishing focus shifts between inputs
    setTimeout(() => { // <--- Changed from contentWindow.setTimeout
        const newActiveElement = contentWindow.document.activeElement;

        // If the element that lost focus was a text input AND the new active element is NOT a text input,
        // it means focus truly moved away from a text input to a non-text input element or off the document.
        if (!isTextInputElement(newActiveElement)) {
            log("Web Focus OUT from a text input, or moved to a non-text input. Notifying OSK Manager.");
            currentFocusedElement = null; // Clear tracking since focus is no longer in an input
            sendFocusMessage('OSK:Web_FocusOut');
        } else {
             // If focus just shifted from one text input to another text input on the same page,
             // we don't send a hide message. The OSK should remain visible.
             log("Web Focus shifted between text inputs. Keeping OSK visible (no message sent).");
        }
    }, 50); // A small delay (e.g., 50ms)
  }

  /**
   * Sets up or re-sets up the event listeners, only if document is ready.
   */
  function setupEventListeners() {
    // Check if document is available and interactive/complete
    if (!contentWindow.document || contentWindow.document.readyState === 'loading') {
      log("Document not ready (or not an HTML/XML document). Deferring event listener setup.");
      return;
    }

    // Only set up listeners for HTTP/HTTPS pages.
    const currentUrl = contentWindow.location.href;
    // Added file:// for local testing convenience. You can remove if not needed.
    if (!currentUrl.startsWith("http://") && !currentUrl.startsWith("https://") && !currentUrl.startsWith("file://")) {
      log("Not an HTTP/HTTPS/FILE page. Skipping detailed event listener setup for:", currentUrl);
      return;
    }

    log("Setting up/re-setting up event listeners.");
    // Remove existing listeners to prevent duplicates if re-called
    contentWindow.document.removeEventListener('focusin', handleFocusIn, true);
    contentWindow.document.removeEventListener('focusout', handleFocusOut, true);

    // Add new listeners (use capture phase for reliable detection)
    contentWindow.document.addEventListener('focusin', handleFocusIn, true);
    contentWindow.document.addEventListener('focusout', handleFocusOut, true);
    log("Event listeners (focusin, focusout) are active.");

    // Initial check for already focused elements after listeners are set up
    const activeElement = contentWindow.document.activeElement;
    if (isTextInputElement(activeElement)) {
        log("Initial active element is a text input. Sending FocusIn.");
        currentFocusedElement = activeElement;
        sendFocusMessage('OSK:Web_FocusIn');
    } else {
        log("No text input element initially focused.");
        // If no text input is focused on initial load, ensure OSK is hidden.
        // This handles cases where a page loads without any initial input focus.
        sendFocusMessage('OSK:Web_FocusOut'); // Ensure OSK is hidden if no input is focused
    }
  }
  sendFocusMessage('OSK:Web_FocusIn'); // test to see if works NOTE: this test works but listening for focus in/out signals does not work please fix.
  sendFocusMessage('OSK:Web_FocusOut');
  /**
   * Handles messages from the chrome script.
   * @param {object} message - The message object.
   */
  addMessageListener(`${SCRIPT_ID}:Reinitialize`, (message) => {
    log("Received Reinitialize message from chrome. Re-setting up listeners for URL:", message.data.url);
    // Use setTimeout to ensure the document is fully ready, especially for about: pages.
    setTimeout(setupEventListeners, 0); // <--- Changed from contentWindow.setTimeout
  });

  // Initial setup when the script is first loaded into the content window.
  // Delay initial setup slightly to ensure DOM is more stable
  setTimeout(setupEventListeners, 100); // <--- Changed from contentWindow.setTimeout

})(this); // Pass `this` as the contentWindow to the IIFE